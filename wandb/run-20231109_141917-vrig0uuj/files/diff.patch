diff --git a/incredibot-sct.py b/incredibot-sct.py
index fdfd885..ea83fcf 100644
--- a/incredibot-sct.py
+++ b/incredibot-sct.py
@@ -315,8 +315,10 @@ class IncrediBot(BotAI): # inhereits from BotAI (part of BurnySC2)
             print(f"Iter: {iteration}. RWD: {reward}. VR: {self.units(UnitTypeId.VOIDRAY).amount}")
 
         # write the file: 
+        # observation(minimap), reward for this step, Action(None if waiting for action, otherwise 0,1,2,3,4,5), Is the game over
         data = {"state": map, "reward": reward, "action": None, "done": False}  # empty action waiting for the next one!
         with open('state_rwd_action.pkl', 'wb') as f:
+            # Save this dictionary as a file(pickle)
             pickle.dump(data, f)
 
         
diff --git a/incredibot-sct1.py b/incredibot-sct1.py
index 18bd709..fb78970 100644
--- a/incredibot-sct1.py
+++ b/incredibot-sct1.py
@@ -1,123 +1,339 @@
-from sc2.bot_ai import BotAI  # parent class we inherit from
-from sc2.data import Difficulty, Race  # difficulty for bots, race for the 1 of 3 races
-from sc2.main import run_game  # function that facilitates actually running the agents in games
-from sc2.player import Bot, Computer  #wrapper for whether or not the agent is one of your bots, or a "computer" player
-from sc2 import maps  # maps method for loading maps to play in.
-from sc2.ids.unit_typeid import UnitTypeId
+import os
+import sys
+import time
+import pickle
 import random
+import cv2
+import numpy as np
+import math
+from sc2.bot_ai import BotAI
+from sc2.data import Difficulty, Race
+from sc2.main import run_game
+from sc2.player import Bot, Computer
+from sc2 import maps
+from sc2.ids.unit_typeid import UnitTypeId
 
-
-class IncrediBot(BotAI): # Inhereits from BotAI (part of BurnySC2)
-    async def on_step(self, iteration: int): # on_step is a method that is called every step of the game
-        print(f"{iteration}, n_workers: {self.workers.amount}, n_idle_workers: {self.workers.idle.amount}, "
-              f"minerals: {self.minerals}, gas: {self.vespene}, cannons: {self.structures(UnitTypeId.PHOTONCANNON).amount}, "
-              f"pylons: {self.structures(UnitTypeId.PYLON).amount}, nexus: {self.structures(UnitTypeId.NEXUS).amount} "
-              f"gateways: {self.structures(UnitTypeId.GATEWAY).amount}, cybernetics cores: {self.structures(UnitTypeId.CYBERNETICSCORE).amount} "
-              f"stargates: {self.structures(UnitTypeId.STARGATE).amount}, voidrays: {self.units(UnitTypeId.VOIDRAY).amount}, supply: {self.supply_used}/{self.supply_cap}")
-        
-
-        # begin logic:
-        
-        await self.distribute_workers()  # 일꾼 분배
-
-        if self.townhalls: # do we have a nexus?
-            nexus = self.townhalls.random # select one (will just be one for now)
-
-        
-            # if we have less than 10 voidrays, build one:
-            if self.structures(UnitTypeId.VOIDRAY).amount < 10 and self.can_afford(UnitTypeId.VOIDRAY):
-                for sg in self.structures(UnitTypeId.STARGATE).ready.idle:
-                    if self.can_afford(UnitTypeId.VOIDRAY):
-                        sg.train(UnitTypeId.VOIDRAY)
-
-
-            # leave room to build void rays
-            supply_remaining = self.supply_cap - self.supply_used
-            if nexus.is_idle and self.can_afford(UnitTypeId.PROBE) and supply_remaining > 4:
-                nexus.train(UnitTypeId.PROBE)
-
-        
-            # if we don't have "any" pylons, we'll build one close to the nexus.
-            elif not self.structures(UnitTypeId.PYLON) and self.already_pending(UnitTypeId.PYLON) == 0:
-                if self.can_afford(UnitTypeId.PYLON):
-                    await self.build(UnitTypeId.PYLON, near=nexus)
-
-        
-            elif self.structures(UnitTypeId.PYLON).amount < 5:
-                if self.can_afford(UnitTypeId.PYLON):
-                    # build from the closest pylon towards the enenmy
-                    target_pylon = self.structures(UnitTypeId.PYLON).closest_to(self.enemy_start_locations[0])
-                    # build as far away from target_pylon as possible:
-                    pos = target_pylon.position.towards(self.enemy_start_locations[0], random.randrange(8, 15))
-                    await self.build(UnitTypeId.PYLON, near=pos)
-
-
-
-            elif self.structures(UnitTypeId.ASSIMILATOR).amount <= 1:
-                for nexus in self.structures(UnitTypeId.NEXUS):
-                    vespenes = self.vespene_geyser.closer_than(15, nexus)
-                    for vespene in vespenes:
-                        if self.can_afford(UnitTypeId.ASSIMILATOR) and not self.already_pending(UnitTypeId.ASSIMILATOR):
-                            await self.build(UnitTypeId.ASSIMILATOR, vespene)
-
-
-
-
-            elif not self.structures(UnitTypeId.FORGE): # if we don't have a forge:
-                if self.can_afford(UnitTypeId.FORGE): # and we can affod one:
-                    # build one near the Pylon that is closest to the nexus:
-                    await self.build(UnitTypeId.FORGE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))
-
-            # if we have less than 3 cannons, let's build some more if possible:
-            elif self.structures(UnitTypeId.FORGE).ready and self.structures(UnitTypeId.PHOTONCANNON).amount < 3:
-                if self.can_afford(UnitTypeId.PHOTONCANNON): # can we afford a cannon?
-                    await self.build(UnitTypeId.PHOTONCANNON, near=nexus) # build one near the nexus
-
-
-            # a gateway? this gets us towards cyb core > stargate > voidray
-            elif not self.structures(UnitTypeId.GATEWAY):
-                if self.can_afford(UnitTypeId.GATEWAY):
-                    await self.build(UnitTypeId.GATEWAY, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))
-
-            # a cyber core? this gets us towards stargate > void ray
-            elif not self.structures(UnitTypeId.CYBERNETICSCORE):
-                if self.can_afford(UnitTypeId.CYBERNETICSCORE):
-                    await self.build(UnitTypeId.CYBERNETICSCORE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))
-
-            # a stargate? this gets us towards void ray
-            elif not self.structures(UnitTypeId.STARGATE):
-                if self.can_afford(UnitTypeId.STARGATE):
-                    await self.build(UnitTypeId.STARGATE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))
-
-
-
-        else:
-            if self.can_afford(UnitTypeId.NEXUS): # can we afford one?
-                await self.expand_now() # build one
-
-
-
-        # if we have more than 3 voidrays, lets's attack
-        if self.units(UnitTypeId.VOIDRAY).amount >= 3:
-            if self.enemy_units:
-                for vr in self.units(UnitTypeId.VOIDRAY).idle:
-                    vr.attack(random.choice(self.enemy_units))
-
-            elif self.enemy_structures:
-                for vr in self.units(UnitTypeId.VOIDRAY).idle:
-                    vr.attack(random.choice(self.enemy_structures))
+SAVE_REPLAY = True
+total_steps = 10000
+steps_for_pun = np.linspace(0, 1, total_steps)
+step_punishment = ((np.exp(steps_for_pun**3) / 10) - 0.1) * 10
+state_file_name = 'state_rwd_action.pkl'
+replay_folder = 'replays'
+os.makedirs(replay_folder, exist_ok=True)
+
+class IncrediBot(BotAI): # inhereits from BotAI (part of BurnySC2)
+    async def on_step(self, iteration: int): # on_step is a method that is called every step of the game.
+        no_action = True
+        while no_action:
+            try:
+                with open('state_rwd_action.pkl', 'rb') as f:
+                    state_rwd_action = pickle.load(f)
+
+                    if state_rwd_action['action'] is None:
+                        #print("No action yet")
+                        no_action = True
+                    else:
+                        #print("Action found")
+                        no_action = False
+            except:
+                pass
+
+
+        await self.distribute_workers() # put idle workers back to work
+
+        action = state_rwd_action['action']
+        '''
+        0: expand (ie: move to next spot, or build to 16 (minerals)+3 assemblers+3)
+        1: build stargate (or up to one) (evenly)
+        2: build voidray (evenly)
+        3: send scout (evenly/random/closest to enemy?)
+        4: attack (known buildings, units, then enemy base, just go in logical order.)
+        5: voidray flee (back to base)
+        '''
+
+        # 0: expand (ie: move to next spot, or build to 16 (minerals)+3 assemblers+3)
+        if action == 0:
+            try:
+                found_something = False
+
+                if self.supply_left < 4:
+                    # build pylons. 
+                    if self.already_pending(UnitTypeId.PYLON) == 0:
+                        if self.can_afford(UnitTypeId.PYLON):
+                            await self.build(UnitTypeId.PYLON, near=random.choice(self.townhalls))
+                            found_something = True
+
+                if not found_something:
+
+                    for nexus in self.townhalls:
+                        # get worker count for this nexus:
+                        worker_count = len(self.workers.closer_than(10, nexus))
+                        if worker_count < 22: # 16+3+3
+                            if nexus.is_idle and self.can_afford(UnitTypeId.PROBE):
+                                nexus.train(UnitTypeId.PROBE)
+                                found_something = True
+
+                        # have we built enough assimilators?
+                        # find vespene geysers
+                        for geyser in self.vespene_geyser.closer_than(10, nexus):
+                            # build assimilator if there isn't one already:
+                            if not self.can_afford(UnitTypeId.ASSIMILATOR):
+                                break
+                            if not self.structures(UnitTypeId.ASSIMILATOR).closer_than(2.0, geyser).exists:
+                                await self.build(UnitTypeId.ASSIMILATOR, geyser)
+                                found_something = True
+
+                if not found_something:
+                    if self.already_pending(UnitTypeId.NEXUS) == 0 and self.can_afford(UnitTypeId.NEXUS):
+                        await self.expand_now()
+
+            except Exception as e:
+                print(e)
+
+
+        #1: build stargate (or up to one) (evenly)
+        elif action == 1:
+            try:
+                # iterate thru all nexus and see if these buildings are close
+                for nexus in self.townhalls:
+                    # is there is not a gateway close:
+                    if not self.structures(UnitTypeId.GATEWAY).closer_than(10, nexus).exists:
+                        # if we can afford it:
+                        if self.can_afford(UnitTypeId.GATEWAY) and self.already_pending(UnitTypeId.GATEWAY) == 0:
+                            # build gateway
+                            await self.build(UnitTypeId.GATEWAY, near=nexus)
+                        
+                    # if the is not a cybernetics core close:
+                    if not self.structures(UnitTypeId.CYBERNETICSCORE).closer_than(10, nexus).exists:
+                        # if we can afford it:
+                        if self.can_afford(UnitTypeId.CYBERNETICSCORE) and self.already_pending(UnitTypeId.CYBERNETICSCORE) == 0:
+                            # build cybernetics core
+                            await self.build(UnitTypeId.CYBERNETICSCORE, near=nexus)
+
+                    # if there is not a stargate close:
+                    if not self.structures(UnitTypeId.STARGATE).closer_than(10, nexus).exists:
+                        # if we can afford it:
+                        if self.can_afford(UnitTypeId.STARGATE) and self.already_pending(UnitTypeId.STARGATE) == 0:
+                            # build stargate
+                            await self.build(UnitTypeId.STARGATE, near=nexus)
+
+            except Exception as e:
+                print(e)
+
+
+        #2: build voidray (random stargate)
+        elif action == 2:
+            try:
+                if self.can_afford(UnitTypeId.VOIDRAY):
+                    for sg in self.structures(UnitTypeId.STARGATE).ready.idle:
+                        if self.can_afford(UnitTypeId.VOIDRAY):
+                            sg.train(UnitTypeId.VOIDRAY)
+            
+            except Exception as e:
+                print(e)
+
+        #3: send scout
+        elif action == 3:
+            # are there any idle probes:
+            try:
+                self.last_sent
+            except:
+                self.last_sent = 0
+
+            # if self.last_sent doesnt exist yet:
+            if (iteration - self.last_sent) > 200:
+                try:
+                    if self.units(UnitTypeId.PROBE).idle.exists:
+                        # pick one of these randomly:
+                        probe = random.choice(self.units(UnitTypeId.PROBE).idle)
+                    else:
+                        probe = random.choice(self.units(UnitTypeId.PROBE))
+                    # send probe towards enemy base:
+                    probe.attack(self.enemy_start_locations[0])
+                    self.last_sent = iteration
+
+                except Exception as e:
+                    pass
+
+
+        #4: attack (known buildings, units, then enemy base, just go in logical order.)
+        elif action == 4:
+            try:
+                # take all void rays and attack!
+                for voidray in self.units(UnitTypeId.VOIDRAY).idle:
+                    # if we can attack:
+                    if self.enemy_units.closer_than(10, voidray):
+                        # attack!
+                        voidray.attack(random.choice(self.enemy_units.closer_than(10, voidray)))
+                    # if we can attack:
+                    elif self.enemy_structures.closer_than(10, voidray):
+                        # attack!
+                        voidray.attack(random.choice(self.enemy_structures.closer_than(10, voidray)))
+                    # any enemy units:
+                    elif self.enemy_units:
+                        # attack!
+                        voidray.attack(random.choice(self.enemy_units))
+                    # any enemy structures:
+                    elif self.enemy_structures:
+                        # attack!
+                        voidray.attack(random.choice(self.enemy_structures))
+                    # if we can attack:
+                    elif self.enemy_start_locations:
+                        # attack!
+                        voidray.attack(self.enemy_start_locations[0])
+            
+            except Exception as e:
+                print(e)
             
-            # otherwise attack enemy starting position
-            else: 
-                for vr in self.units(UnitTypeId.VOIDRAY).idle:
-                    vr.attack(self.enemy_start_locations[0])
-
-
 
+        #5: voidray flee (back to base)
+        elif action == 5:
+            if self.units(UnitTypeId.VOIDRAY).amount > 0:
+                for vr in self.units(UnitTypeId.VOIDRAY):
+                    vr.attack(self.start_location)
+
+
+        map = np.zeros((self.game_info.map_size[0], self.game_info.map_size[1], 3), dtype=np.uint8)
+
+        # draw the minerals:
+        for mineral in self.mineral_field:
+            pos = mineral.position
+            c = [175, 255, 255]
+            fraction = mineral.mineral_contents / 1800
+            if mineral.is_visible:
+                #print(mineral.mineral_contents)
+                map[math.ceil(pos.y)][math.ceil(pos.x)] = [int(fraction*i) for i in c]
+            else:
+                map[math.ceil(pos.y)][math.ceil(pos.x)] = [20,75,50]  
+
+
+        # draw the enemy start location:
+        for enemy_start_location in self.enemy_start_locations:
+            pos = enemy_start_location
+            c = [0, 0, 255]
+            map[math.ceil(pos.y)][math.ceil(pos.x)] = c
+
+        # draw the enemy units:
+        for enemy_unit in self.enemy_units:
+            pos = enemy_unit.position
+            c = [100, 0, 255]
+            # get unit health fraction:
+            fraction = enemy_unit.health / enemy_unit.health_max if enemy_unit.health_max > 0 else 0.0001
+            map[math.ceil(pos.y)][math.ceil(pos.x)] = [int(fraction*i) for i in c]
+
+
+        # draw the enemy structures:
+        for enemy_structure in self.enemy_structures:
+            pos = enemy_structure.position
+            c = [0, 100, 255]
+            # get structure health fraction:
+            fraction = enemy_structure.health / enemy_structure.health_max if enemy_structure.health_max > 0 else 0.0001
+            map[math.ceil(pos.y)][math.ceil(pos.x)] = [int(fraction*i) for i in c]
+
+        # draw our structures:
+        for our_structure in self.structures:
+            # if it's a nexus:
+            if our_structure.type_id == UnitTypeId.NEXUS:
+                pos = our_structure.position
+                c = [255, 255, 175]
+                # get structure health fraction:
+                fraction = our_structure.health / our_structure.health_max if our_structure.health_max > 0 else 0.0001
+                map[math.ceil(pos.y)][math.ceil(pos.x)] = [int(fraction*i) for i in c]
+            
+            else:
+                pos = our_structure.position
+                c = [0, 255, 175]
+                # get structure health fraction:
+                fraction = our_structure.health / our_structure.health_max if our_structure.health_max > 0 else 0.0001
+                map[math.ceil(pos.y)][math.ceil(pos.x)] = [int(fraction*i) for i in c]
+
+
+        # draw the vespene geysers:
+        for vespene in self.vespene_geyser:
+            # draw these after buildings, since assimilators go over them. 
+            # tried to denote some way that assimilator was on top, couldnt 
+            # come up with anything. Tried by positions, but the positions arent identical. ie:
+            # vesp position: (50.5, 63.5) 
+            # bldg positions: [(64.369873046875, 58.982421875), (52.85693359375, 51.593505859375),...]
+            pos = vespene.position
+            c = [255, 175, 255]
+            fraction = vespene.vespene_contents / 2250
+            if vespene.is_visible:
+                map[math.ceil(pos.y)][math.ceil(pos.x)] = [int(fraction*i) for i in c]
+            else:
+                map[math.ceil(pos.y)][math.ceil(pos.x)] = [50,20,75]
+
+        # draw our units:
+        for our_unit in self.units:
+            # if it is a voidray:
+            if our_unit.type_id == UnitTypeId.VOIDRAY:
+                pos = our_unit.position
+                c = [255, 75 , 75]
+                # get health:
+                fraction = our_unit.health / our_unit.health_max if our_unit.health_max > 0 else 0.0001
+                map[math.ceil(pos.y)][math.ceil(pos.x)] = [int(fraction*i) for i in c]
+
+
+            else:
+                pos = our_unit.position
+                c = [175, 255, 0]
+                # get health:
+                fraction = our_unit.health / our_unit.health_max if our_unit.health_max > 0 else 0.0001
+                map[math.ceil(pos.y)][math.ceil(pos.x)] = [int(fraction*i) for i in c]
+
+        # show map with opencv, resized to be larger:
+        # horizontal flip:
+
+        cv2.imshow('map',cv2.flip(cv2.resize(map, None, fx=4, fy=4, interpolation=cv2.INTER_NEAREST), 0))
+        cv2.waitKey(1)
+
+        if SAVE_REPLAY:
+            # save map image into "replays dir"
+            cv2.imwrite(f"replays/{int(time.time())}-{iteration}.png", map)
+
+
+
+        reward = 0
+
+        try:
+            attack_count = 0
+            # iterate through our void rays:
+            for voidray in self.units(UnitTypeId.VOIDRAY):
+                # if voidray is attacking and is in range of enemy unit:
+                if voidray.is_attacking and voidray.target_in_range:
+                    if self.enemy_units.closer_than(8, voidray) or self.enemy_structures.closer_than(8, voidray):
+                        # reward += 0.005 # original was 0.005, decent results, but let's 3x it. 
+                        reward += 0.015  
+                        attack_count += 1
+
+        except Exception as e:
+            print("reward",e)
+            reward = 0
 
-run_game( # run game is a function that runs the game.
-    maps.get("Simple64"), # the map we are playing on
-    [Bot(Race.Protoss, IncrediBot()), # runs our coded bot, protoss race, and we pass out bot object
-     Computer(Race.Zerg, Difficulty.Hard)], # runs a pre-made computer agent, zerg race, with a hard difficulty.
-     realtime=False, # When set to True, the agent is limited in how long each step can take to procees.
-)
\ No newline at end of file
+        
+        if iteration % 100 == 0:
+            print(f"Iter: {iteration}. RWD: {reward}. VR: {self.units(UnitTypeId.VOIDRAY).amount}")
+
+# 게임 실행 부분
+def main():
+    result = run_game(
+        maps.get("Simple64"),
+        [Bot(Race.Protoss, IncrediBot()), Computer(Race.Zerg, Difficulty.Hard)],
+        realtime=False,
+    )
+
+    # Post-game reward calculation
+    rwd = 500 if str(result) == "Result.Victory" else -500
+    with open("results.txt", "a") as f:
+        f.write(f"{result}\n")
+
+    # Final state save
+    final_state = {'state': np.zeros((224, 224, 3), dtype=np.uint8), 'reward': rwd, 'action': None, 'done': True}
+    with open(state_file_name, 'wb') as f:
+        pickle.dump(final_state, f)
+
+    cv2.destroyAllWindows()
+    time.sleep(3)
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/state_rwd_action.pkl b/state_rwd_action.pkl
index 5fcd4e0..9906c22 100644
Binary files a/state_rwd_action.pkl and b/state_rwd_action.pkl differ
